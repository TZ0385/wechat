#  【刻刀-rs】Rustscan现代化高速端口扫描工具

原创 EOTH [ Eonian Sharp ](javascript:void\(0\);)

**Eonian Sharp** ![]()

微信号 Eonian_sharp

功能介绍 Eonian Sharp | 永恒之锋，专注APT框架、渗透测试攻击与防御的研究与开发，没有永恒的安全，但有永恒的正义之锋击破黑暗的不速之客。

____

___发表于_

收录于合集

#刻刀系列 5 个

#Rust 3 个

#工具 13 个

#渗透测试 9 个

# 武器锈化

"刻刀-rs"系列，即是使用Rust编写的工具，将工具尽可能的锈化（rust翻译为铁锈）。

# Rustscan

![](https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20230714174651.png)

说到端口扫描，大家都听说过Nmap，这是端口扫描界的老大哥，得益于多年的社区维护，真正的开源的精神，然后就是指纹识别的准确性，因为它是使用RFC标准的偏大指纹库，另外根据优秀的算法使用概率性猜测不确定的指纹。

扫描稳定，然后又全面，历史悠久，非常的经典，一些新开发的端口扫描工具也不错，一些小老弟也是不错的，比如zmap使用异步探测，Nmap是C语言编写的，缺点就是非常的慢，目前使用大多使用Go、Python编写的端口扫描工具，使用多线程和异步扫描，可以快速进行探测端口，如Masscan，既快速又全面，尽管如此，也有非常多的新选手向老大哥发起挑战，Rustscan，速度超群，扫描也稳定，最主要的，它是基于Rust开发。

Rustscan解决了Nmap扫描端口慢的问题，但不挑战老大哥，在扫描端口完成后，调用Nmap进行指纹识别。一旦完成第一个扫描阶段，它将使用Nmap作为带有特定标签再次扫描。默认会使用操作系统探测标签。

![](https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20230714174653.png)

下面是Rustscan官方的介绍

# Rustscan特性

  *  **3 秒** 内扫描所有 65k 端口。

  * 完整的脚本引擎支持。自动将结果传输到 Nmap 中，或使用我们的脚本（或编写您自己的脚本）来执行您想要的任何操作。

  * 适应性学习。RustScan 使用得越多，它的性能就会越好。这里没有臃肿的机器学习，只有基本的数学。

  * 您所期望的平常情况。IPv6、CIDR、文件输入等。

  * 自动将端口传送到 Nmap 中。

 **提高速度/准确性**

  * 批量大小

这允许我们同时处理更多内容，从而提高速度。我正在做的一些实验是改变打开文件的限制。您可以使用手动执行此操作ulimit -n 70000，然后使用 运行
rustscan -b 65535。这 _应该会_ 同时扫描所有 65535 端口。但这是非常实验性的。

对于非实验性的速度增加，请缓慢增加批量大小，直到它不再打开端口或中断。

  * 准确性（和一定的速度）

要提高准确性，最简单的方法是增加超时时间。默认值为 1.5 秒，通过将其设置为 4 秒 (4000)，我们告诉 RustScan“如果我们在 4
秒内没有收到端口的回复，则假设它已关闭”。

降低准确度会带来一些速度加成，但我的测试发现，批量大小极大地改变了速度，而超时确实改变了速度，但变化不大。

 **误报**

有些人未经尝试就声称 RustScan 存在误报。从字面上看，这是不可能的。

RustScan 通过内置 Rust 套接字模块使用完整的 TCP 3 路握手连接。

该模块已被证明是正确的。

谷歌、苹果和其他大公司一直在使用 Rust 的网络功能。如果 Rust 这种语言的网络实现很糟糕，导致误报，那么它会很快被发现并在几分钟内修复。

看起来我们有误报的唯一方法是，如果有人使用另一个不能保证不会误报的扫描仪，并接受该扫描仪的信息而不是 RustScans。

 **可扩展**

无脚本

    
    
    rustscan --scripts none

使用此选项不会运行任何脚本。

实际上，这无需自定义脚本或 nmap 即可运行 RustScan。

自定义脚本

自定义脚本在程序运行后执行。您编写（或使用）脚本，然后 RustScan 执行它。

RustScan 支持以下脚本语言：

  * Python

  * shell

  * Perl

要执行自定义脚本，我们需要一个rustscan_scripts.toml位于$HOME/.rustscan_scripts.toml.

    
    
    rustscan --scripts custom

该文件应如下所示：

    
    
    # Test/Example ScriptConfig file  
      
    # Tags to filter on scripts. Only scripts containing all these tags will run.  
    tags = ["core_approved", "example"]  
      
    # If it's present then only those scripts will run which has a tag ports = "80". Not yet implemented.  
    #  
    # ex.:  
    # ports = ["80"]  
    # ports = ["80","81","8080"]  
    ports = ["80"]  
      
    # Only this developer(s) scripts to run. Not yet implemented.  
    developer = ["example"]

  

让我们来看看这个。

首先，作为参考，这是一个基本的 Python 脚本。

    
    
    #!/usr/bin/python3  
    #tags = ["core_approved", "example",]  
    #developer = [ "example", "https://example.org" ]  
    #trigger_port = "80"  
    #call_format = "python3 {{script}} {{ip}} {{port}}"  
      
    # Scriptfile parser stops at the first blank line with parsing.  
    # This script will run itself as an argument with the system installed python interpreter, only scanning port 80.  
    # Unused filed: ports_separator = ","  
      
    import sys  
      
    print('Python script ran with arguments', str(sys.argv))

  

注意：脚本的元数据存储为注释。第一行始终是shebang。

使用 RustScan 运行其他工具

系统中安装的任何工具（如 Nmap、GoBuster 等）都可以使用 RustScan 运行。

我们默认使用 Nmap 执行此操作。

要执行另一个程序，请创建一个调用该程序的 shell 脚本。因此，要调用 Nmap，请使用 RustScan 脚本引擎创建一个 shell
脚本，然后使用以下函数：

    
    
    $ nmap -vvv -p {{port}} {{ip}}

  

您可以用 GoBuster 或任何程序替换它。只要该程序已安装并且在环境 $PATH 中可访问。

# 使用

参数

![](https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20230714174654.png)

![](https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20230714174655.png)

# 技巧

对于一些配置较低的目标，可使用多次、慢速、随机、少量的方法。

    
    
     .\rustscan.exe -a ip -g -t 3500 --tries 3 -r 1-10000 --scan-order random

实验证明，1-20000的大范围，4500的超时更加准确

    
    
    .\rustscan.exe -a ip --accessible -t 4500 --tries 3 -r 1-20000 --scan-order random

我个人一般使用

    
    
     .\rustscan.exe --addresses IP --batch-size 6666 --ulimit 6666 --greppable --accessible --ports 80,11211,7001,7002,27017,50070,6378,3306,873,8888,8080（一些常用端口，也可以使用范围1-10000） --timeout 1666 --tries 3 -- -A

# Rustscan与其它工具对比

![](https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20230714174656.png)

# 警告

默认情况下，RustScan每秒扫描3000个端口。

这可能会对服务器造成损害，或者让你非常明显地扫描服务器，从而触发一个不受欢迎的响应，比如让你的IP地址被阻塞。

有两种方法可以解决这个问题:

减少批量大小:rustscan -
b10一次扫描10个端口，每个端口的默认超时时间为1000(1秒)。因此，最大批处理持续时间可以比超时时间更长:即开始(和完成处理)批处理中的所有扫描所需的时间。

增加超时时间:rustscan -T 5000意味着rustscan将在端口上等待最多5秒的响应。

你可以同时使用这两种方法，让它按照你的想法变慢或变快。一个有趣的最爱是1秒超时的65535批量大小。实际上，这意味着在不到2秒的时间内从nmap中获得结果。

请不要对敏感服务器使用此工具。它主要是为捕获标志事件而设计的，而不是具有敏感数据的真实世界的服务器。

# Rust

我想了很久，还是将rust语言向大家介绍一下，因为我想了很久，我学rust快一年了，结果怎么样，结果就是非常的难，虽然没有放弃，但几乎没有啥进展。因为它非常的难。所以我想了很久，我将它介绍给大家，真的非常的难，不过我还是要介绍一下，因为它非常的难，我是想说，因为它非常的完美，优秀。

Rust几乎是完美的，从写底层操作系统、网络通讯其它语言到后端、API接口，甚至前端。

Rust几乎是完美的，它占用内存小，但性能拔群（优于java、go，优于python百倍）。

Rust几乎是完美的，它非常的安全，因为安全是它的特性，因为一个智能的编译器，不安全的代码将无法通过编译，并提示很准确、详细的报错信息。

Rust 程序设计语言的本质实际在于 **赋能** （ _empowerment_ ）：无论你现在编写的是何种代码，Rust
能让你在更为广泛的编程领域走得更远，写出自信。（这一点并不显而易见）

引入一段Nicholas Matsakis 和 Aaron Turon的介绍

举例来说，那些“系统层面”的工作涉及内存管理、数据表示和并发等底层细节。从传统角度来看，这是一个神秘的编程领域，只为浸润多年的极少数人所触及，也只有他们能避开那些臭名昭著的陷阱。即使谨慎的实践者，亦唯恐代码出现漏洞、崩溃或损坏。

Rust 破除了这些障碍：它消除了旧的陷阱，并提供了伴你一路同行的友好、精良的工具。想要 “深入” 底层控制的程序员可以使用
Rust，无需时刻担心出现崩溃或安全漏洞，也无需因为工具链不靠谱而被迫去了解其中的细节。更妙的是，语言设计本身会自然而然地引导你编写出可靠的代码，并且运行速度和内存使用上都十分高效。

已经在从事编写底层代码的程序员可以使用 Rust 来提升信心。例如，在 Rust
中引入并行是相对低风险的操作，因为编译器会替你找到经典的错误。同时你可以自信地采取更加激进的优化，而不会意外引入崩溃或漏洞。

但 Rust
并不局限于底层系统编程。它表达力强、写起来舒适，让人能够轻松地编写出命令行应用、网络服务器等各种类型的代码——在本书中就有这两者的简单示例。使用 Rust
能让你把在一个领域中学习的技能延伸到另一个领域：你可以通过编写网页应用来学习 Rust，接着将同样的技能应用到你的 Raspberry Pi（树莓派）上。

本书全面介绍了 Rust 为用户赋予的能力。其内容平易近人，致力于帮助你提升 Rust 的知识，并且提升你作为程序员整体的理解与自信。欢迎你加入 Rust
社区，让我们准备深入学习 Rust 吧！

—— Nicholas Matsakis 和 Aaron Turon

因此，Rust 语言用了足足 6 年时间，才发布了尽善尽美的 1.0 版本。

# Rust诞生

![](https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20230714174657.png)

大家知道 Rust 的作者到底因为何事才痛下决心开发一门新的语言吗？

说来挺有趣，在 2006年的某天，作者工作到精疲力尽后，本想回公寓享受下生活，结果发现电梯的程序出 Bug
崩溃了，要知道在国外，修理工可不像在中国那样随时待岗，还要知道，他家在 20 多楼！

最后，他选择了妥协，去酒店待几天等待电梯的修理。

当然，一般人可能就这样算了，毕竟忍几天就过去了嘛。但是这名伟大的程序员显然也不是一般人，他面对害他流离失所的电梯拿起了屠龙宝刀 - Rust。

自此，劈开一个全新的编程世界。

为何又来一门新语言？简而言之，因为还缺一门无 GC 且无需手动内存管理、性能高、工程性强、语言级安全性以及能同时得到工程派和学院派认可的语言，而 Rust
就是这样的语言。你也可以回忆下熟悉的语言，看是不是有另外一门可以同时满足这些需求：)

至于 Rust 最为人诟病的点，那也就一个：学习曲线陡峭。不过当语言生态起来后，这都不算问题。

# 缓解内卷

有人说 Rust 作为新语言会增加内卷，其实恰恰相反，Rust 可以缓解内卷。为何不说 C++ 内卷，而说 Java、Python、JS
内卷？不就是后几个相对简单、上手容易嘛？而 Rust 怎么看也是 C++ 级别的上手难度。

其实从我内心不可告人的角度出发，并不希望 Rust 大众化，因为这样可以保饭碗、保薪资，还能拥有行业内的地位。但是从对 Rust
的喜爱角度出发，我还是希望能卷一些。不过，目前来看真的卷不动，现在全世界范围内 Rust 的需求都大于供给，特别是优秀的 Rust 程序员更是难寻。

与 Go 语言相比，成为一名优秀的 Rust 程序员所需的门槛高得多，例如融汇贯通 Rust
语言各种中高级特性、闭着眼睛趟过各种坑、不用回忆无需查找就能立刻写出最合适的包/模块/方法、性能/安全/工程性的权衡选择信手拈来、深层性能优化易如反掌、异步编程小菜一碟，更别说
Rust 之外的操作系统、网络、算法等等相关知识。

所以，Rust 可以缓解内卷，而不是增加内卷。可以说是程序员的福音，不再是被随意替换的螺丝钉。

![](https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20230714174658.png)rust吉祥物

# 效率

下面从三个角度来谈谈 Rust 的效率：学习、运行、开发。

 **学习效率**

众所周知，Rust 的学习曲线相当陡峭。起初，对此说法我还嗤之以鼻，随着不断的深入，现在也很认可这个说法。Rust
之难，不在于语言特性，这些都可以很容易学到，而在于：

实践中如何融会贯通的运用遇到了坑时（生命周期、借用错误，自引用等）如何迅速、正确的解决大量的标准库方法记忆及熟练使用，这些是保证开发效率的关键心智负担较重，特别是初中级阶段好在这本书就是干这个的，包君满意，不满意退...
要不还是骂我吧 :D

 **运行效率**

得益于各种零开销抽象、深入到底层的优化潜力、优质的标准库和第三方库实现，Rust 具备非常优秀的性能，和 C、C++ 是 一个级别。

同时 Rust 有一个极大的优点：只要按照正确的方式使用 Rust，无需性能优化，就能有非常优秀的表现，不可谓不惊艳。

现在有不少用 Rust 重写的工具、平台都超过了原来用 C、C++ 实现的版本，将老前辈拍死在沙滩上，俨然成为一种潮流～～

 **开发效率**

Rust 的开发效率可以用先抑后扬来形容。在最初上手写项目时，你的开发速度将显著慢于 Go、Java
等语言，不过，一旦开始熟悉标准库、熟悉生命周期和所有权的常用解决方法，开发效率将大幅提升，甚至当形成肌肉记忆后，开发效率将不会慢于这些语言，而且原生就能写出高质量、安全、高效的代码，可以说中高级
Rust 程序员就是高效程序员的代名词。

 **个人的好处**

学习 Rust 对个人也有极大的好处。

 **成为更好的程序员**

要学好 Rust，你需要深入理解内存、堆栈、引用、变量作用域等这些其它高级语言往往不会深入接触的内容。另外，Rust 会通过语法、编译器和 clippy
这些静态检查工具半帮助半强迫的让你成为更优秀的程序员，写出更好的代码。

同时，当你掌握 Rust
后，就会自发性的想要去做一些更偏底层的开发，这些都可以帮助你更加了解操作系统、网络、性能优化等底层知识，也会间接或者直接的接触到各种算法和数据结构的实现。

慢慢的，你就在成为那个更好的程序员，也是更优秀的自己。

 **增加不可替代性**

语言难学也有好处，一旦掌握，你将具备较强的不可替代性，不再是一个简单的工具人角色。看看现在内卷严重的
Java，工具人有多少！一个人离职，另外一个人很快就能替补上。

当然，我不是说 Rust 会给公司带来这种隐形的维护成本，毕竟这其实是一种双赢，公司收获了更优秀的程序员（不可否认的是 Rust
程序员普遍来说水平确实更高，毕竟都是有很好的编程基础、也很有追求的自驱型人才），而你也收获了更稳定的工作环境，甚至是更高的收入。

 **团队的好处**

先不说安全、可靠性等对公司团队非常友好的特性，就说 Rust 程序只要能跑起来，那代码质量其实就是相当不错的，因为 Rust
编译器实在是一名严师厉友，甚至有些鸡毛。

正因为这较高的质量下限，我们在代码 review 时不用过于担心潜在的各种坑，得益于此，可以实现更加高效的开发、review、merge 流程。

由于 Rust 语言拥有异常强大的编译器和语言特性，Rust 的代码天然就会比其它语言拥有更少的 Bug。同时 Rust
拥有非常完善的工具链、最好的包管理工具，决定了 Rust 非常适合大型团队的协作开发。

也许 Rust 在开发速度上不是最快的，但是从开发 + 维护的角度来看，这个成本在各个语言中绝对是很小的。当然，如果你的公司就追求做出来能用就行，那
Rust 确实有些灰姑娘的感觉。

还有一点很重要，现在的 Rust 程序员往往拥有更出众的能力和学习自驱性，因此团队招到的人天然就保持了较高的底线。如果你有幸招到一个优秀的 Rust
程序员，那真是捡到宝了，他也会同时带动周围的人一起慢慢优秀（优秀的 Rust
程序员比较好辨别，门槛低的语言就并没有那么好辨别）。总之，一个这样的程序员会给团队带来远超他薪资的潜在回报和长远收益。

 **开源**

目前 Rust 的主战场是在开源上，Go 的成功也证明了农村包围城市( 开源包围商业 )的可行性。

UI 层开发，Rust 的 WASM 发展的如火如荼，隐隐有王者风范，在 JS 的基础设施领域，Rust 也是如鱼得水，例如 swc、 deno 等。同时
nextjs 也是押宝 Rust，可以说 Rust 在前端的成功完全是无心插柳柳成荫。基础设施层、数据库、搜索引擎、网络设施、云原生等都在出现 Rust
的身影，而且还不少。系统开发，目前 Linux 已经将 Rust 语言纳入内核，是继 C
语言后第二门支持内核开发的语言，不过刚开始将主要支持驱动开发。系统工具，现在最流行的就是用 Rust 重写之前 C、C++
写的一票系统工具，还都获得了挺高的关注和很好的效果，例如 sd, exa, ripgrep, fd, bat 等。操作系统，正在使用 Rust
开发的操作系统有好几个，其中最有名的可能就是谷歌的 Fuchsia，Rust 在其中扮演非常重要的角色。区块链，如果 Rust
的份额说第二，应该没人敢稳说自己是第一吧？类似的还有很多，我们就不一一列举。总之，现在有大量的项目正在被 Rust
重写，同时还有海量的项目在等待被重写，这些都是赚取github 星星和认可的好机会。在其它语言杀成一片红海时，Rust 还留了一大片蓝海等待大家的探索！

# 相比其他语言 Rust 的优势

由于篇幅有限，我们这里不会讲述详细的对比，就是简单介绍下 Rust 的优势，并不是说 Rust 优于这些语言，大家轻喷：)

GoRust 语言表达能力更强，性能更高。同时线程安全方面 Rust 也更强，不容易写出错误的代码。包管理 Rust 也更好，Go 虽然在 1.10
版本后提供了包管理，但是目前还比不上 Rust 。

C++Rust 与 C++ 的性能旗鼓相当，但是在安全性方面 Rust 会更优，特别是使用第三方库时，Rust 的严格要求会让三方库的质量明显高很多。

语言本身的学习，Rust 的前中期学习曲线会更陡峭，但是在实际的项目开发过程中，C++ 会更难，代码也更难以维护。

Java除了极少数纯粹的数字计算性能，Rust 的性能全面领先于 Java 。同时 Rust 占用内存小的多，因此实现同等规模的服务，Rust
所需的硬件成本会显著降低。

Python性能自然是 Rust 完胜，同时 Rust 对运行环境要求较低，这两点差不多就足够抉择了。不过 Python 和 Rust
的彼此适用面其实也不太冲突。

# 使用现状

AWS 从 2017 年开始就用 Rust 实现了无服务器计算平台：AWS Lambda 和 AWS Fargate，并且用 Rust 重写了
Bottlerocket OS 和 AWS Nitro 系统，这两个是弹性计算云 (EC2) 的重要服务Cloudflare 是 Rust
的重度用户，DNS、无服务计算、网络包监控等基础设施都与 Rust 密不可分Dropbox 的底层存储服务完全由 Rust 重写，达到了数万 PB
的规模Google 除了在安卓系统的部分模块中使用 Rust 外，还在它最新的操作系统 Fuchsia 中重度使用 RustFacebook 使用 Rust
来增强自己的网页端、移动端和 API 服务的性能，同时还写了 Hack 编程语言的虚拟机Microsoft 使用 Rust 为 Azure
平台提供一些组件，其中包括 IoT 的核心服务GitHub 和 npmjs.com，使用 Rust 提供高达每天 13 亿次的 npm 包下载Rust
目前已经成为全世界区块链平台的首选开发语言TiDB，国内最有名的开源分布式数据库尤其值得一提的是，AWS 实际上在押宝 Rust，内部对 Rust
的使用已经上升到头等公民 first-class 的地位。

# 总结

连续 6 年最受欢迎的语言当然不是浪得虚名。无 GC、效率高、工程性强、强安全性以及能同时得到工程派和学院派认可，这些令 Rust
拥有了自己的特色和生存空间。社区的友善，生态的快速发展，大公司的重仓跟进，一切的一切都在说明 Rust 的璀璨未来。

当然，语言毕竟只是工具，我们不能神话它，但是可以给它一个机会，也许，你最终能收获自己的真爱 ：)

  

# 参考

[1] https://course.rs/into-rust.html

[2] https://www.rust-lang.org/

[3] https://github.com/RustScan/RustScan

  

# 获取

向公众号发送 **rustscan** 即可获取编译+翻译好的Rustscan。

预览时标签不可点

微信扫一扫  
关注该公众号

[知道了](javascript:;)

微信扫一扫  
使用小程序

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

： ， 。   视频 小程序 赞 ，轻点两下取消赞 在看 ，轻点两下取消在看

