#  vCenter RCE 详细分析过程 (CVE-2021–22005)

Jang  [ Khan安全攻防实验室 ](javascript:void\(0\);)

**Khan安全攻防实验室** ![]()

微信号 KhanCJSH

功能介绍 安全不是一个人，我们来自五湖四海。研究方向Web内网渗透，免杀技术，红蓝攻防对抗，CTF。

____

__

收录于话题

1.任意文件创建（需要启用 CEIP）

根据解决方法，可以看出在“  _/analytics/telemetry/ph/api/hyper/send_ ”和“
_/analytics/ph/api/dataapp/agent_  ”存在危险，其中只有 RhttpProxy 服务的配置，“
_/analytics/telemetry_  ” 可以直接访问：

  

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201728.png)

  

“ _/analytics/telemetry_ ”được

处理bởi类AsyncTelemetryController

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201738.png)

  

调用 _/analytics/telemetry_ 端点时，会根据通过 HTTP
传入的参数生成“TelemetryRequest”，包括：collectorId、collectorInstanceId、...  

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201739.png)

  

继续进入TelemetryService。 _processTelemetry()_ ，上面刚刚创建的 TelemetryRequest
将被提交到一个队列并在不久之后在TelemetryRequestProcessorRunnable处执行。

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201741.png)

  

进入TelemetryLevelBasedTelemetryServiceWrapper 之后。 _processTelemetry()_
，服务器从传入的collectorId、collectorInstanceId参数实现getTelemetryLevel() ：

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201743.png)

  

按照目前的程序流程，还会继续调用 DefaultTelemetryLevelService.getTelemetryService() 来获取
TelemtryLevel。该代码执行以下操作：

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201744.png)

  

在这里我们可以很容易地看到：如果 CEIP 功能被禁用，程序将始终将遥测级别返回为 OFF！

完成关卡并返回TelemetryLevelBasedTelemetryServiceWrapper。 _processTelemetry()，_
我们可以看到，如果TelemetryLevel = OFF，服务端将不会继续处理请求并返回。

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201746.png)

  

因此，此错误有一个特殊要求，即启用 CEIP 功能才能继续！

假设我们的环境启用了 CEIP，服务器继续进入LogTelemetryService分支。 _processTelemetry_
()，这里的处理代码只是记录刚刚传入的TelemetryRequest，日志的内容就是请求体：

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201748.png)

  

日志文件存储在

/var/log/vmware/analytics/prod/_c_i<

instance name> .json

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201749.png)

  

并且因为filename中同时包含collectorId和collectorInstanceId，所以一看到这一段，就想到了可以在路径遍历中添加“../”字符，在另一个文件夹中随意创建一个文件的情况。

但是，当尝试第一个请求时，什么也没发生，没有创建日志，也没有返回错误。

继续调试到“this. _logger .info()”看更清楚，F7，F8一会，遍历路径后到达logger的fileName所在的位置如下：

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201750.png)

  

在"/var/log/vmware/analytics/prod/"这个文件夹中的"_c_i"，

可以通过路径遍历

"/var/log/vmware/analytics/prod/_c_i/。./.../.../.../.../.../tmp/test1111111.json
"被认为没有找到。

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201751.png)

  

此路径遍历仅在前一个文件夹也存在时才有效：

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201752.png)

  

幸运的是，经过一段时间的杂项模糊测试后，能够在服务器上创建一个新文件夹：

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201754.png)  
  

使用 _c="" 和 _i="/<name>"，完整路径现在为：

“ /var/log/vmware/analytics/prod/_c_i/11247.json ”

当 Logger 调用RollingFileManager 时。 _createManager()_ ，服务器将检查父文件夹是否存在，这里是“ _c_i
”，由于这个文件夹不存在，它很快就会被创建。

创建文件夹“ _c_i ”后，可以成功完成创建上述任意文件的请求路径遍历：

  

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201755.png)

  

然而，这还不是结束，问题仍然很困难，

文件的内容和路径可以任意修改，但文件名必须有扩展名“.json”，不能写web shell并执行！

很多人发现了上面的bug，也卡在这里，不能RCE

  

  

2.任意 Web Shell 创建

感觉解决方法不够完美，找到一个完美的bug：RCE没有严格条件，只好下载patch和diff，

两个补丁之间的一些细微变化如下：

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201756.png)

  

大部分都是更多的机制来检查collectorId，文件名...以避免写shell。

其中，上面提到的AsyncTelemetryController有一个bug，剩下的bug肯定是在“DataAppAgentController”！

在新版本中，带有 action=collect 的端点“/dataapp/agent”已被完全删除：

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201758.png)

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201759.png)

在rhttpproxy的声明中，没有声明允许访问端点“  _/analytics/ph/api/dataapp/agent_  ”，目前这个端点只能
_通过_ 本地15080端口 _访问_ ，回到公告，这次修复的bug中，还有一个bug是CVE-2021-22017——rhttpproxy
bypass，也是上报CVE-2021-22005的作者报告的。

  

果然，作者找到了绕过rhttpproxy的方法，结合端点“/dataapp/agent”的漏洞，形成了一个RCE-In-Onehit链……

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201800.png)

从开始到现在，都忘了那个经典的 tomcat 案例，还在用绕过代理过滤器：“ ..;/ ”

  

正如预期的那样，“..;/”是关键：  

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201801.png)

如何访问端点的问题已经解决了，现在只是如何再次写入文件。

  * 还有一个bug，可以直接写文件到服务器，但是内容比较有限，而且文件名会有.properties扩展名，所以我不关注这个bug了，读者可以回头看看，再往这个方向发展

  

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201803.png)

  

这里的调试过程相当漫长和棘手，经过一段时间的 F7 和 F8 不断，并通过某种链接方法，我停在ResourceItemToJsonLdMapping

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201805.png)

  

ResourceItemToJsonLdMapping。 _evaluateMappingExpression()_ 然后继续调用 Velocity
来evaluate() 模板：

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201806.png)

有了这个。_mappingCode ”是可控值：

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201808.png)

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201813.png)

堆栈跟踪：

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201815.png)

从这里我们可以评估（）一个任意模板，但这还不足以使用常见的paylaks进行RCE：

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201816.png)

新的 Velocity 版本有一些黑名单来阻止对“java.lang.Class”类方法的调用：

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201818.png)

因此，不能直接调用 Class.forName() 或 Class 的某个方法来执行。但是，在 vCenter
的当前上下文中，没有这样合适的变量，只有如下的一些变量：

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201819.png)

  

其中一个已经工作，并且可以用来编写任意文件。那就是“ GLOBAL-logger ”：

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201820.png)

以下是使用$GLOBAL-logger编写 shell 的步骤：

第一步：将日志路径设置为任意文件，

第 2 步：通过日志记录编写 web shell

第三步：关闭日志文件并返回日志文件名的旧值

生成的文件将如下所示：

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20220303201821.png)

  

UG9DIOinhumike+8mg0KDQpodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PVdWSjhSRFI3WHpzDQoNClBvQyDohJrmnKzvvJpodHRwczovL2dpc3QuZ2l0aHViLmNvbS90ZXN0YW51bGwvYzJmNmZkMDYxYzQ5NmVhOTBkZGVlMTUxZDY3MzhkMmU=

目前VMware已经发布了相关漏洞的补丁，建议受影响的用户参考VMware官方公告及时升级更新。

下载链接：

https://www.vmware.com/security/advisories/VMSA-2021-0020.html

  

预览时标签不可点

收录于话题 #

 个

上一篇 下一篇

阅读

分享 收藏

赞 在看

____已同步到看一看[写下你的想法](javascript:;)

前往“发现”-“看一看”浏览“朋友在看”

![示意图](//res.wx.qq.com/mmbizwap/zh_CN/htmledition/images/pic/appmsg/pic_like_comment55871f.png)

前往看一看

**看一看入口已关闭**

在“设置”-“通用”-“发现页管理”打开“看一看”入口

[我知道了](javascript:;)

__

已发送

取消 __

####  发送到看一看

发送

vCenter RCE 详细分析过程 (CVE-2021–22005)

最多200字，当前共字

__

发送中

[写留言](javascript:;)

微信扫一扫  
关注该公众号

[知道了](javascript:;)

微信扫一扫  
使用小程序

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

： ， 。 视频 小程序 赞 ，轻点两下取消赞 在看 ，轻点两下取消在看

