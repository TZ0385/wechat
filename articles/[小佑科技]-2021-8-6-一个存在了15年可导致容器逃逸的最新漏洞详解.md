##  一个存在了15年可导致容器逃逸的最新漏洞详解

[ 小佑科技 ](javascript:void\(0\);)

**小佑科技** ![]()

微信号 xiaoyoudosec

功能介绍
北京小佑科技专注于云计算安全的科技公司，我们开发了自主知识产权的PAAS容器安全防护产品，解决容器全生命周期的安全问题，同时为客户提供高品质的安全事件应急处理、合规咨询等安全服务，以产品加服务的方式为客户提供高价值的安全解决方案。

____

__

收录于话题

  

CVE-2021-22555：一个影响2006年（Linux kernel v2.6.19-rc1 发布）至今（Linux kernel
v5.12-rc8）的所有Linux内核版本的漏洞，可导致本地提权与容器逃逸； **该漏洞是个内核级漏洞，跟Linux的发行版本没有关系**
，也就是说只要Linux 内核版本在v2.6.19-rc1 ～v5.12-rc8 之间的内核，都存在被黑客利用该漏洞攻击的可能。

该漏洞是由Andy Nguyen (theflow@)发现，于2021年07月16日发布。

换句话说，该漏洞已经存在了15年之久，都没有被人发现。该漏洞将允许本地用户通过用户名空间获取权限提升，和容器逃逸。

  

  

  

  

#  **1.漏洞概述**

* * *

 ****  

漏洞编号|  CVE-2021-22555  
---|---  
内核组件| kernel-netfilter  
漏洞类型| Linux kernel堆溢出、特权提升  
影响版本| Linux Kernel : v2.6.19-rc1 ～ v5.12-rc8  
  
简述: Linux 内核模块Netfilter中存在一处权限提升漏洞，在 64位系统 上为 32位进程 处理 setsockopt
IPT_SO_SET_REPLACE（或 IP6T_SO_SET_REPLACE）时，如果内核选项CONFIG_USER_NS
、CONFIG_NET_NS被开启，则攻击者可以通过该漏洞实现权限提升，以及从docker、k8s容器中实施容器逃逸。

  

  
  

  

#  **2.漏洞环境和样例**

* * *

 ****  

 **  
**

##  **2.1. 环境准备**

  

Linux发行版：Ubuntu 20.04.2 LTS

Linux kernel 版本：5.8.0-48-generic

  

如图：

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20210806154708.png)

  

  

##  **2.2. 利用样例**

  

![]()

  

  

  

#  **3 漏洞原理**

* * *

 ****  

  

在Linux内核代码 net/netfilter/x_tables.c中的 xt_compat_target_from_user
函数内的第1129行，在使用memset()时并未对传进来的参数进行校验，会导致在写0时，越过堆的大小，导致“堆溢出”，从而破坏堆与堆之间的边界。

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20210806154709.png)

  

而写超的0
的内核内存，刚好又在应用层程序（恶意程序）通过堆喷技术拿到感知控制。通过搜索，可以找到被写超的内核内存；恶意程序在应用层建立与这段内核内存的联系，把要执行代码commit_creds(prepare_kernel_cred(NULL))封装到回调函数内；利用内核机制在内核内存中建立与回调机制使用关系，再把刚才封装的函数地址更新到内核内存中。当主动释放这段内核内存，触发回调函数，从而调用到commit_creds()函数把权限升级到root权限。

  

#  **4 前导技术知识点**

* * *

  

##  **4.1 UAF (Use-After-Free)**

 **  
**

是一个与程序运行期间不正确使用动态内存相关的漏洞 利用方式。

程序在释放内存位置后，系统不会马上回收内存。指针指向的那段内存依然存在，并且内容没有被清除，攻击者可以利用该错误来入侵该程序。

（本次漏洞重点使用。通过UAF，可以达到同一块内存在不同的操作对象之间交换控制管理权）

  

##  **4.2 SMAP & SMEP**

 **  
**

SMAP(Supervisor Mode Access Prevention)：管理模式访问保护–禁止内核CPU访问用户空间的数据

SMEP(Supervisor Mode Execution Prevention)：管理模式执行保护–禁止内核CPU执行用户空间的代码

（并不会因为你权限高就能访问/执行低权限的资源，你的就是你的，我的就是我的）

  

SMEP和SMAP导致我们不能像从前那样，利用恶意进程提权到内核权限后，扭头去执行布置在用户态的恶意shellcode，用户态shellcode注入也不好使了（Linux
内核漏洞防御机制）。

  

##  **4.3 KASLR**

 **  
**

KASLR（kernel address space layout randomization）也就是内核地址空间布局随机化。KASLR技术允许kernel
image加载到VMALLOC区域的任何位置。当KASLR关闭的时候，kernel image都会映射到一个固定的链接地址。

对于黑客来说是透明的，因此安全性得不到保证。KASLR技术可以让kernel
image映射的地址相对于链接地址有个偏移。如果bootloader支持每次开机随机生成偏移数值，那么可以做到每次开机kernel
image映射的虚拟地址都不一样。

因此，对于开启KASLR的kernel来说，不同的产品的kernel image映射的地址几乎都不一样。因此在安全性上有一定的提升（Linux
内核漏洞防御机制）。

  

##  **4.4 rop 链攻击**

 **  
**

rop（Return Oriented Programming）
。X86架构下，函数调用规则是，当刚跳转到其他函数去执行时，从被调用者的视角看：栈顶是返回地址，紧接着是自己的参数。

被调用者会对栈空间进行一系列操作，保存寄存器和存储临时变量，但在即将退出时会清理自己消耗的栈空间，以使其回到自己被调用前的栈空间，保持栈平衡；

最后，被调用者以ret指令结尾，ret指令将栈顶地址传递到 RIP寄存器 ，随后代码也就跳转到之前栈顶存放的返回地址处；

rop链即是基于以上这个简单的原理，在代码空间中寻找以ret结尾的代码片段或函数（代码片段称为Rop
gadgets），组合可以实现拓展可写栈空间、写入内存、shell等功能，依靠ret将 代码执行权 紧握在自己的手里。

  

  

##  **4.5 一段代码的运行**

 **  
**

在计算机体系中，所有的行为逻辑，都是要以“程序”为媒介得以执行。当然，这也包含了所有“恶意行为”在内的病毒、木马等待。

而“程序”的本质是通过代码来对“现实行为”在计算机内的行为仿真（程序没有“恶意”和“非恶意”之分，恶意的是写这份代码的人心）；既然是代码，也是要遵照计算机体系的约定。

###  

###  **4.5.1 代码运行的条件**

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20210806154711.png)

  

在Linux系统中所有的行为都是被“权限”所规范起来。

  

换句话说，程序想要被运行起来就需要“获得”相应的权限。而在Linux系统权限是被严格的划分。我们可以从2个维度（应用层/内核层）来对权限进行了解。

  

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20210806154712.png)

  

###  **4.5.2 应用层（Ring 3）**

 **  
**

也就是平时我们操作Linux界面。在应用层中是以用户为单位进行管理，又划分成2类：特权用户（也就是root），普通用户。

Linux限定了普通用户的行为，也包含普通用户的程序；在普通用户模式下，有很多系统级的接口、功能，都是不能使用的；基本也就是只能使用主机的“计算能力”，不能使用到“管理能力”。

  

###  **4.5.4 内核层（Ring 0）**

 **  
**

操作系统是对物理硬件的抽象，而内核层是操作系统的核心。

在内核层中，没有像应用层那样，做权限区分，任何执行代码都是一样的权限。

而内核层相对于用户层，拥有的特权是最高。

  

###  **4.5.5 漏洞利用逻辑**

 **  
**

根据前面提到的，想要运行代码，需要2个条件：

1、代码在内存中

2、装载代码的内存拥有执行权限

  

一个普通用户的程序，正常情况下只能通过高权限的授权，来提升自己的权限，除此别无他法。

而CVE-2021-22555漏洞可以通过“内核特权”来打破这一规则。

  

  

#  **5 漏洞利用步骤**

* * *

 ****  

###  **5.1 堆喷：建立线性的内核堆内存**

 **  
**

（也是为后续UAF攻击做准备）

通过系统提供的消息队列功能，建立大量的消息队列，并往每个消息队列里面传入消息（每个消息大小：4096）。这些消息会缓存到内核当中。

缓存在内核，也就意味着有大量的内存占用。而当有大量的内存申请使用，内核的内存管理模块为了减小内存碎片的问题，会把相邻的内存返回给内存使用者。

也就是说，这些缓存的消息，在内存中是连续存在，紧挨着的。

  

如图：

![]()

  

这样还不够，再次往各个消息队列发送消息，这次发送的消息大小是1024。而在消息队列中的消息是用链表的方式来连接的，在内存中的布局如图：

  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20210806154713.png)

  

这里面的选用 4096 大小作为第一条消息，是为了适配漏洞代码 memset() 做格式化的大小。

  

而选用1024 大小作为每二条消息，是为了利用上漏洞后，当内核内存使用，与后续的回调机制匹配。

  

###  **5.2 漏洞触发 & UAF攻击**

 **  
**

现在读出部分各个消息队中的 4096大小的消息，其目的是为了释放在内核内存中缓存的内存。在读出的消息的同时内存也得到释放。

  

接下应用层利用 socket 触发漏洞函数。触发代码：

setsockopt(fd, SOL_IP, IPT_SO_SET_REPLACE, &data, sizeof(data))

data 的大小通过人为的方式来构造，其中sizeof(data) 的大小，会传到漏洞语句。造成堆写0溢出，踩到相邻的内存。

内核层对应的漏洞函数 xt_compat_target_from_user
被触发时，会在内核层申请内核内存。根据UAF攻击原理，xt_compat_target_from_user
函数内申请的内存刚好会是上面消息队在内核层释放的内存块。

而该内存块相连的是其它的 4096大小的消息内存块。当漏洞函数被触发，写超的内存，就会写到相邻的 4096 消息内。

4096 消息在应用层可以通过遍历，来找出被踩的那块内核消息块。

在溢出写0的长度是在应用层可以人为的控制，而这里，我们设计溢出的长度为 2 个字节。

根据消息结构体在内核层中的定义，溢出写0的2个字节刚好会覆盖消息结构体内的指向下一条1024消息的指针的后2位。就会导致被溢出踩的4096消息会指向另一个1024消息，而这条1024同时会被另一个4096的消息指向。

也就是同一个1024消息被2个4096消息指向，为后续的UAF利用提供了条件。

  

如图：

![]()

####  **5.2.1 一点题外话**

 **  
**

该漏洞的利用开始就是从写超2个字节的堆内存，而该漏洞的发现者也因此获取得了1
0000$的奖励。而在作者后续的文章说明中，也是很幽默地把该点写到文章的标题上。

如图：

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20210806154714.png)

  

###  **5.3 绕过内核 SMAP 机制**

 **  
**

其实目的是为了把权限升级的相关的代码传到内核层让，让内核层的权限去运行权限升级的代码，来提升用户层用户的权限。

绕过SMAP的基础，就是要知道内核内存的地址。知道地址的基础，把我们要提升权限的代码以ROP攻击链的方式写到该内核内存当中。

通过对消息队的遍历，找到了被双重引用的1024消息，而目前还不知道该被双重引用的1024消息的地址。

不知道该消息的内核内存地址，是没办法绕过SMAP机制，同时在后面作为ROP链的媒介内存，在不知道内存地址的情况下，是没办法使用的。

  

接下来就是需要知道该消息的内核内存地址了。

好在可以通过消息结构(struct msg_msg)的 m_ts字段，再利用 copy_msg()函数

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20210806154715.png)来读取出被双重指向的1024消息的相邻消息。（设置被双重指向的1024消息的m_ts字段大于DATALEN_MSG(4096
- sizeof(struct msg_msg)) ）

再通过该相邻消息找出被双重指定的1024消息的内核内存地址。

现在我们得到了内核内存地址，就可以把我们的ROP链的代码写到该内核内存地址上，从而达到绕过SMAP机制。

  

  

###  **5.4 解除内核消息队列的限制**

在内核的消息队列，也就只是消息结构类型（struct
msg_msg），并且还需要保证里面的元素的合法性。换句话说，我们就不能使用消息队列的对象来做内核内存的修改对象，因为没有可塑性。

需要找一种有可塑造的内核结构消息来指向该内核消息队列内存地址。

这里使用 struct sk_buff 结构体类型， sk_buff就没有 struct msg_msg的内核限制。

利用双重指向的1024消息的其中一个引用，来释放该1024消息。再使用struct
sk_buff类型的消息来堆喷1024大小，正常情况下，通过堆喷会找到刚释放出被双重指定的1024消息。而这样做的目的是为了通过另一种控制的方式（sk_buff）来指向了该内核内存地址。

到目前为止，我们拿到了一段内核内存，大小1024，并且还一个struct sk_buff类型的指针可以对它进行操作。

（为了方便大家理解，再次解释一下：该步骤的目的是为了把同一块内存的控制管理权限转交给 struct sk_buff 结构；因为在原消息结构 struct
msg_msg 类型在内核中是不允许对结构体做超范围的操作）

  

  

###  **5.5 找一个有回调机制的结构**

 **  
**

也就是找到一个结构体内有函数指针的对象。

这里选用 struct pipe_buffer 结构对象。

该结构体中的 const struct pipe_buf_operations *ops；刚好可以用来存放回调函数。

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20210806154716.png)

![]()

该结构体刚好占1024字节，同时也很容易使用 pipe()函数来制成。

  

  

###  **5.6 绕过KASLR & SMEP**

 **  
**

调用 pipe()申请 struct pipe_buffer 结构时，ops字段的内容会默认填充为anon_pipe_buf_ops，而内容又存在内核的
.data段内：

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20210806154717.png)

  

因为在内核中的.data和.text段之间的偏移固定，我们可以计算内核程序代码基地址。

这就又要用到堆喷技术了，在上面我们提到有一段内核内存被sk_buff指向，同时还被另一个消息队列给指针。

利用消息队列释放该段内核内存。随后，调用大量的pipe()函数来实现堆喷，找回刚才被释放的内核内存。

这样同一块内核内存就被 pipe 和 sk_buff同时指向，同时具有操作权。

  

而const struct pipe_buf_operations *ops 中有一个名为 release的回调函数，会在 pipe被闭时实调用到。

  

利用内核内存部署上我们的ROP攻击链（也就是我们要提升权限的函数），把并ROP链的触发写到ops的release内。

ROP链代码：

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20210806154718.png)

  

最后关闭pipe会调用release，也是会执行到我们的权限提升函数，得到root权限。

到此已完成了漏洞的利用。再利用root权限返回一个root权限的shell。

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20210806154719.png)

  

 **6  修复建议**

* * *

 ****  

请尽快升级Linux内核到安全版本，如下：

Linux Kernel 5.12(b29c457a6511435960115c0f548c4360d5f4801d)，5.10.31, 5.4.113,
4.19.188, 4.14.231, 4.9.267, 4.4.267

  

  

临时修补建议：

RedHat建议，用户可通过以下命令禁止非特权用户执行CLONE_NEWUSER、CLONE_NEWNET来执行此漏洞：

  * 

    
    
    echo 0 > /proc/sys/user/max_user_namespaces

  
  

  

#  **7 参考**

* * *

 ****  

https://github.com/google/security-
research/blob/master/pocs/linux/cve-2021-22555/writeup.md

  

https://github.com/google/security-research/security/advisories/GHSA-
xxx5-8mvq-3528

  

END

关于鲲鹏安全实验室

  

  

  

鲲鹏安全实验室专注于容器安全和业务灰黑产对抗的研究，收集和挖掘容器相关技术的安全漏洞，采集业务灰黑产情报，研究对抗手段。并将研究成功转换为产品和服务。

  

  

  

  

  

  

  

内容编辑：鲲鹏安全实验室 鬼画符  责任编辑：剁肉工  

  

* * *

  
  
  

 **往 期推荐**

  
  
  
 **[再
获认可|中国网络安全百强报告(2021)发布，小佑科技再次上榜创新能力百强](http://mp.weixin.qq.com/s?__biz=MzU2NzgyMjc2Nw==&mid=2247484430&idx=1&sn=e533240181f6996ae0ce9003e3b49555&chksm=fc9614cecbe19dd8f0ef026cfcc706253b74d2f14c78cf6f69c3e434a9085a8166178a5322f1&scene=21#wechat_redirect)**
**  
**[
**小佑科技创始人袁曙光受邀参加全球技术峰会GOTC深圳站专题论坛**](http://mp.weixin.qq.com/s?__biz=MzU2NzgyMjc2Nw==&mid=2247484467&idx=1&sn=2429a2f4269ccd340411c8c1ba5eb57d&chksm=fc9614f3cbe19de5d6f7723f8d094428e6e9f5f63a9c002862b9928cb67844473b2340c98ce1&scene=21#wechat_redirect)  
 **[C
VE-2021-30465——runc竞争条件漏洞复现与分析](http://mp.weixin.qq.com/s?__biz=MzU2NzgyMjc2Nw==&mid=2247484412&idx=1&sn=4747bbc4fcee3cac49b6e22ea229a6b0&chksm=fc96133ccbe19a2a35259bbbf680679b7d383884a8855ba61b1b44366d8595a56077166b4e4a&scene=21#wechat_redirect)**

  
  

![](http://hk-proxy.gitwarp.com/https://raw.githubusercontent.com/tuchuang9/tc1/refs/heads/main/public/20210806154720.png)

  

预览时标签不可点

收录于话题 #

个 __

上一篇 下一篇

阅读

分享 收藏

赞 在看

____已同步到看一看[写下你的想法](javascript:;)

前往“发现”-“看一看”浏览“朋友在看”

![](//res.wx.qq.com/mmbizwap/zh_CN/htmledition/images/pic/appmsg/pic_like_comment55871f.png)

前往看一看

**看一看入口已关闭**

在“设置”-“通用”-“发现页管理”打开“看一看”入口

[我知道了](javascript:;)

__

已发送

取消 __

####  发送到看一看

发送

一个存在了15年可导致容器逃逸的最新漏洞详解

最多200字，当前共字

__

发送中

写下你的留言

微信扫一扫  
关注该公众号

微信扫一扫  
使用小程序

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

[知道了](javascript:;)

**长按识别前往小程序**

![]()

